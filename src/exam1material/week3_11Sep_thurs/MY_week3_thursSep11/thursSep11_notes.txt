HW 3 due Tues Sep 16

Exam 1 Thurs Sep 18
    take full time
    closed notes
    mix of multiple choice (like in-class and practice quizzes) 
        and open-ended (like homework)
    will post practice material
    will review on Tuesday

////////////////////////////

Today:
- Continue natural deduction
- Review proof syntax, AND rules
- OR rules in natural deduction
- Using natural deduction to prove two statements are equivalent
- Equivalent if-statements
- If time, rules for implies operator

//////////////////////////

Want to prove a *sequent* (argument) of the form:

    premises ⊢ conclusion

where *premises* is a comma-separated list.


In truth tables?

Argument was valid when every truth assignment made all premises true also made conclusion true


Natural deduction?

Make different claims
apply deduction rules to build new claims


//////////////////////////

AND rule summaries.

         P   Q
AndI : ---------
         P ∧ Q


AndI(lineNum1, lineNum2)

AndI = can only use we already have two separate claims




///

          P ∧ Q               P ∧ Q
AndE1 : ---------   AndE2 : ---------
           P                    Q

AndE: Can use it when there's an AND statement


//////////////////////////////////

Reminder: natural deduction proof syntax:

Natural deduction proof syntax.

(premises) ⊢ (conclusion) is called a "sequent"
Proof(
    1 (  claim          ) by Justification,
    2 (  claim          ) by Justification,
    ...
    10 (  conclusion    ) by Justification
)


--> what justifications so far?

Premises, AndI, AndE1, AndE2


/////////////////////////////////

Review examples: and2.sc, and3.sc

/////////////////////////////////

Prove that ∧ is commutative with natural deduction

andCommute.sc



////////////////////////////////

OR introduction

          P                      Q
OrI1 : ---------        OrI2 : ---------
        P ∨ Q                   P ∨ Q




Syntax:

OrI1(lineWithLeft)
OrI2(lineWithRight)

///////////////////////////////////////////

Example:

(p ∧ q) ⊢ (p ∨ q)
Proof(
    1 ( p ∧ q   ) by Premise,
    2 ( p ) by AndE1(1),
    4 (p ∨ q) by OrI1(2)

)

Or, could have done:

(p ∧ q) ⊢ (p ∨ q)
Proof(
    1 ( p ∧ q   ) by Premise,
    2 ( p ) by AndE1(1),
    3 ( q ) by AndE2(1),
    4 (p ∨ q) by OrI(2, 3)

    OR
    
    1 ( p ∧ q   ) by Premise,
    2 ( q ) by AndE2(1),
    4 (p ∨ q) by OrI(2)
)





///////////////////////////////////////////

OR elimination


Idea:
- If an OR statement is true, what do we know?

p ∨ q

At least one of p or q is true
Separately consider the case where p is true
...try to reach some conclusion



- What if we can reach the same conclusion no matter which side
    of the OR is true?






Rule summary:


               SubProof(          SubProof(
                  Assume ( P ),      Assume ( Q ),
      P ∨ Q       ...                ...
                  R                  R
               ),                  ),
OrE : ---------------------------------------------
                         R


How does this relate to programming?


if (condition) {
    some result
}
else {
    some result
}

--> what do we know is true here?

some result is true




///////////////////////////////

Syntax for using OrE:

(some line numbers are removed for ease of reading)

a ( P ∨ Q   )       by Justification,
b SubProof(
    Assume(P),
    ...
    ( R   )         by Justification
),
c SubProof(
    Assume(Q),
    ...
    ( R   )         by Justification
),
d ( R   )           by OrE(a, b, c)


////////////////////////////////

Example: prove that OR is commutative (or1.sc)

p ∨ q       vs      q ∨ p


////////////////////////////////

(in-class quiz)

////////////////////////////////

Do you think we could prove:

p ∨ q ⊢ p ∧ q
Proof(
    1 ( p ∨ q) by Premise,
    
    2 SubProof(
        3 Assume(p),
        // get stuck
    )

)



What is the only way to prove an argument is invalid?

One examples from a truth table that makes all premises true but the conclusion false


////////////////////////////////

Order of operations:

p ∨ q ∨ r

with parentheses?

--> If I used OrE, what would be the two assumes in
    the subproofs?

SubProof(
    Assume ( ??? ),
    SubProof(
        Assume (p),
        ...
        R
    ),
    SubProof(
        Assume(q),
        ...
        R
    ),

    R using OrE with p ∨ q and two subproofs
),
SubProof(
    Assume ( r )
    ...
    R
)


////////////////////////////////

Proving equivalence.

--> how do we prove two statements are equal in truth tables? 
For every possible truth assignments both statements have the same output

two truth tables, one for each statement
showed that for each input (truth assignment), both statements had the same output


--> how do we do it with proofs?

premise ⊢ conclusion

two proofs:
statement1 ⊢ statement 2

statement2 ⊢ statement1




How would we write these arguments in words? 

If the premises are true, then the conclusion is true

If statement1 is true, then statement2 is true.
If statement2 is true, then statement1 is true.


--> what does this tell you you could do instead of proving equivalence
    with two truth tables?

(statement1 -> statement2) ^ (statement2 -> statement1)

Expect a tautology



////////////////////////////////

Example: prove one of the distributive laws

p ∨ (q ∧ r)     is equivalent to       (p ∨ q) ∧ (p ∨ r)


(orDist1.sc and orDist2.sc)

////////////////////////////////

Equivalence in if-statements.

Consider this if-statement:

if (extraCredit == true || grade >= 80) {
    if (extraCredit == true || grade <= 90) {
        //do stuff
    }
}

--> translate to propositional logic



--> what is an equivalent, simpler if-statement?


///////////////////////////////////

Implies-elimination, ImplyE

          P, P → Q
ImplyE: -----------
            Q



(This rule is also called "modus ponens")



Example:

//Suppose we know x > 5. What can we conclude?

if (x > 5) {
    y = 17;
}



///////////////////////////////

Syntax for using ImplyE:

a ( P       )   by Justification,
b ( P → Q   )   by Justification,
c ( Q       )   by ImplyE(b, a)


What you type for → 
    __>:

////////////////////////////////////////

Example (imply1.logika):

(p ∧ q) → r,  p → q,  p  ⊢ r



Example (imply2.logika):

p → r,  q → r,  p ∨ q  ⊢ r


////////////////////////////////////////

Next time:
- Finish rules for implies operator (these WILL be on exam 1)
- Review for exam
